use crate::engine::book::OrderBook;
use crate::storage::layout::{OrderId, Price, Quantity, Side};

/// Heuristic for pre-allocating the Trade vector.
///
/// **Optimization Note:**
/// In HFT, aggressive orders often "sweep" multiple levels of the book.
/// A capacity of 16 covers ~99% of sweeps without triggering a heap reallocation
/// (malloc/memcpy) during the critical matching loop.
const AVG_SWEEP_SIZE: usize = 16;

/// Represents a successful match event between two orders.
#[derive(Debug, Clone)]
pub struct Trade {
    /// The ID of the resting order (Maker) that was removed/reduced.
    pub maker_id: OrderId,
    /// The ID of the incoming order (Taker) that initiated the trade.
    pub taker_id: OrderId,
    /// The execution price (always the Maker's price).
    pub price: Price,
    /// The amount matched in this specific event.
    pub quantity: Quantity,
    /// The side of the Maker (e.g., if MakerSide = Buy, this was a Sell taking a Buy).
    pub maker_side: Side,
}

/// Executes an incoming order against the book.
///
/// This function implements the **Matching Engine Core Logic**.
/// It iterates through the opposing side of the book, generating trades
/// until the incoming order is filled or the spread is no longer crossed.
///
/// # Returns
/// A tuple containing:
/// 1. `Quantity`: The remaining quantity of the incoming order (if any).
///    If > 0, the caller should treat this as a new "Maker" order.
/// 2. `Vec<Trade>`: A list of execution reports generated by this order.
pub fn execute_match(
    book: &mut OrderBook,
    taker_id: OrderId,
    taker_side: Side,
    taker_price: Price,
    mut taker_qty: Quantity,
) -> (Quantity, Vec<Trade>) {
    // Pre-allocate to avoid reallocations during a standard sweep.
    let mut trades = Vec::with_capacity(AVG_SWEEP_SIZE);

    loop {
        // 1. FULL FILL CHECK: If incoming is filled, stop matching.
        if taker_qty.0 == 0 {
            break;
        }

        // 2. LIQUIDITY CHECK: Get the best order on the OPPOSITE side.
        //    - Buying? Look at the lowest Sell (Best Ask).
        //    - Selling? Look at the highest Buy (Best Bid).
        let best_match_ptr = match taker_side {
            Side::Buy => book.best_ask,
            Side::Sell => book.best_bid,
        };

        // 3. EMPTY BOOK CHECK: If no orders exist, stop matching.
        //    The remaining quantity will become a resting order.
        let mut maker_ptr = match best_match_ptr {
            Some(ptr) => ptr,
            None => break,
        };

        // 4. MEMORY ACCESS
        // SAFETY: We hold a mutable reference to `book` for the duration of this function.
        // Rust's borrow rules prevent any other thread or function from modifying the Arena
        // while we are here. Thus, the pointer retrieved from `best_bid/ask` is guaranteed valid.
        let maker_order = unsafe { maker_ptr.as_mut() };

        // 5. PRICE CROSSING CHECK (The "Limit" Logic)
        //    A match only occurs if the Taker's price meets or exceeds the Maker's terms.
        let crosses = match taker_side {
            Side::Buy => taker_price >= maker_order.price, // Willing to pay Maker's Ask or more
            Side::Sell => taker_price <= maker_order.price, // Willing to sell for Maker's Bid or less
        };

        if !crosses {
            // SPREAD PROTECTION:
            // Since the book is sorted by best price, if we don't cross the top order,
            // we mathematically cannot cross any subsequent orders.
            break;
        }

        // 6. EXECUTION: Calculate fill quantity (Partial vs Full).
        //    We can only trade the minimum of what Taker wants and Maker has.
        let trade_qty = std::cmp::min(taker_qty.0, maker_order.qty.0);

        // 7. EVENT GENERATION
        trades.push(Trade {
            maker_id: maker_order.id,
            taker_id,
            price: maker_order.price, // Trade price is determined by the resting order (Maker)
            quantity: Quantity(trade_qty),
            maker_side: maker_order.side,
        });

        // 8. UPDATE STATE
        taker_qty.0 -= trade_qty;
        maker_order.qty.0 -= trade_qty;

        // 9. CLEANUP: If Maker is fully filled, remove it from the book.
        //    This updates the Head pointers (best_bid/ask) to the next order in the list.
        if maker_order.qty.0 == 0 {
            book.remove_order(maker_ptr);
        }
    }

    (taker_qty, trades)
}
